# Migrating Next.js Apps from Supabase to Convex – Comprehensive Guide

This guide outlines a step-by-step migration of two TypeScript Next.js applications (originally using Supabase for auth, database, storage, etc.) to the Convex backend-as-a-service. All code will be generated by AI, so the instructions are **explicit, unambiguous, and robust**. We cover each feature area in depth:

## 1\. Authentication (User Accounts & Identity)

Supabase’s built-in email/OAuth auth will be replaced with Convex-compatible auth. Convex itself **accepts OpenID Connect JWTs** for authentication, meaning you can integrate any major auth provider[*\[1\]*](https://docs.convex.dev/auth#:~:text=Convex%20is%20compatible%20with%20most,OAuth%20endpoints%20to%20verify%20them). There are two main approaches:

* **Use a Third-Party Auth Provider:** Convex recommends using providers like **Clerk**, **Auth0**, or **NextAuth (Auth.js)** for a full-featured auth system[*\[2\]*](https://docs.convex.dev/auth#:~:text=,to%20be%20used%20for%20authentication). For example, using **Auth.js (NextAuth)** on the Next.js side in combination with Convex is a robust solution. In this setup, your Next.js app handles sign-in (with OAuth providers or magic links), and Convex acts as the database adapter for Auth.js. Convex provides an official NextAuth adapter that defines Convex tables for users, accounts, sessions, etc., and securely stores/retrieves Auth.js data in Convex[*\[3\]*](https://stack.convex.dev/nextauth-adapter#:~:text=)*[\[4\]](https://stack.convex.dev/nextauth-adapter#:~:text=56%20const%20authTables%20%3D%20,64%20%20verificationTokens%3A%20defineTable%28verificationTokenSchema%29.index)*. After configuring NextAuth with Convex, each login creates a user document in Convex (e.g. in a *"users"* table), and Convex functions can trust the JWT provided by NextAuth. Another option is **Clerk**, which has deep Next.js integration; you’d use Clerk’s frontend SDK and Convex’s Clerk integration to authenticate users in Convex functions. In either case, the client passes a JWT from the provider to Convex – Convex will verify it and identify the user.  
* **Use Convex’s Built-In Auth (Beta):** Convex offers a native auth library (currently in beta) to implement email/password, passcode, or social logins *within* Convex[*\[5\]*](https://docs.convex.dev/auth#:~:text=For%20client,access%20codes%2C%20or%20via%20passwords). This avoids external services but has fewer features (no built-in MFA, etc.) and may require more custom logic. If you choose Convex Auth, you’ll install the Convex Auth npm package and configure providers (e.g. Google OAuth) in your Convex backend. Note that Next.js support for Convex Auth is experimental[*\[6\]*](https://docs.convex.dev/auth#:~:text=Convex%20Auth%20is%20in%20beta), so using a third-party (as above) is often simpler for production apps.

**Identity in Convex Functions:** In Convex, any function (query/mutation/action) can access the current user’s identity via the context. For example, in a Convex function you might write:

import { mutation } from "./\_generated/server";

export const updateProfile \= mutation({  
  args: { fullName: v.string() },  
  handler: async (ctx, args) \=\> {  
	const user \= await ctx.auth.getUserIdentity();  
	if (user \=== null) {  
  	throw new Error("Unauthenticated call");  // No user logged in  
	}  
	// User is authenticated; proceed to update profile  
	const userId \= user.tokenIdentifier;  
	await ctx.db.patch(userId as Id\<"users"\>, { name: args.fullName });  
  },  
});

In this snippet, *ctx.auth.getUserIdentity()* returns a *UserIdentity* object if the request has a valid JWT, or *null* if not[*\[7\]*](https://docs.convex.dev/auth/functions-auth#:~:text=%2F%2F%20...%20,%7D). We **always** perform this check at the start of any protected function. Convex doesn’t enforce Row-Level Security like Postgres; instead, you implement authorization in code. The recommended pattern is to *“check if the user is logged in and allowed to perform the action at the beginning of each public function”[\[8\]](https://docs.convex.dev/auth#:~:text=This%20means%20Convex%20doesn%27t%20need,authorization%20framework%20for%20your%20needs)*. This means verifying *identity \!== null* (user is authenticated), and if necessary, confirming the user’s roles or ownership before proceeding.

**Structuring Auth in Next.js:** In a Next.js App Router project, you’ll likely create a context provider (e.g. *ConvexClientProvider.tsx*) to wrap your app with Convex and the auth provider. For instance, if using Auth0 or Clerk, Convex provides *\<ConvexProviderWithAuth0\>* and similar helpers that tie Convex’s client to the auth context[*\[9\]*](https://docs.convex.dev/client/nextjs/app-router/#:~:text=const%20convex%20%3D%20new%20ConvexReactClient%28process)*[\[10\]](https://docs.convex.dev/client/nextjs/app-router/#:~:text=cacheLocation%3D,Auth0Provider%3E%20%29%3B)*. On the Next.js server (for server components or route handlers), use the provider’s server-side SDK (e.g. Clerk’s or Auth0’s SDK) to verify JWTs and forward them to Convex when calling Convex functions[*\[11\]*](https://docs.convex.dev/client/nextjs/app-router/#:~:text=To%20access%20user%20information%20or,provided%20by%20Clerk%20and%20Auth0). In practice, once a user is logged in via the chosen method, the Convex React client will include the user’s token on each request automatically, so *ctx.auth.getUserIdentity()* will work inside Convex functions.

**Example – NextAuth Integration:** If using NextAuth (Auth.js), you would set up the Convex \<-\> NextAuth adapter. This involves defining Convex schema tables for users, sessions, etc. (as given by the adapter)[*\[12\]*](https://stack.convex.dev/nextauth-adapter#:~:text=7%20export%20const%20userSchema%20%3D,16%20%20expires%3A%20v.number)*[\[13\]](https://stack.convex.dev/nextauth-adapter#:~:text=53%20%20transports%3A%20v.optional%28v.string%28%29%29%2C%2054,providerAccountId)* and installing some Convex functions that NextAuth will call (secured by a secret)[*\[14\]*](https://stack.convex.dev/nextauth-adapter#:~:text=15%2016%20const%20adapterQuery%20%3D,mutation%2C)*[\[15\]](https://stack.convex.dev/nextauth-adapter#:~:text=25%20%20args%3A%20,30)*. NextAuth would issue a JWT for the logged-in user, and you’d configure the Convex client to use that JWT. A Convex query could then do:

const identity \= await ctx.auth.getUserIdentity();  
if (identity) {  
  console.log("User email:", identity.email);  
}

Convex ensures the JWT’s signature is valid (for the configured issuer). The *UserIdentity* will include standard claims like *sub* (user ID), *email*, *name*, etc., when using providers like Auth0 or Clerk[*\[16\]*](https://docs.convex.dev/auth/functions-auth#:~:text=The%20UserIdentity%20object%20returned%20by,JWT%20tokens%20and%20OpenID%20scopes)*[\[17\]](https://docs.convex.dev/auth/functions-auth#:~:text=,definition%20in%20the%20OpenID%20docs)*.

**Summary:** Replace Supabase Auth by either integrating an external auth provider (preferred for richer features) or using Convex’s own auth. In all cases, enforce identity checks in Convex functions (*ctx.auth*) to secure data access. After migration, user login flows in the Next.js apps should remain similar, but the verification of identity and retrieval of user info will occur via Convex.

## 2\. Database Schema and Relationships

Supabase uses a PostgreSQL schema with tables, foreign keys, and Row-Level Security (RLS) policies. Convex, in contrast, is a document store with **table schemas defined in TypeScript**. We will translate the schema as follows:

·  	**Define Convex Tables:** In Convex, you create a *schema.ts* that lists all tables and their field types. Each table is defined with *defineTable()*, and you specify field validators using Convex’s *v* (value validation) library[*\[18\]*](https://docs.convex.dev/database/schemas#:~:text=export%20default%20defineSchema%28,name%3A%20v.string%28%29%2C%20tokenIdentifier%3A%20v.string). For example, if Supabase had a table *users(id UUID PRIMARY KEY, name TEXT, ...)* and a table *messages(id SERIAL PK, user\_id UUID REFERENCES users, body TEXT)*, in Convex you would define:

// convex/schema.ts  
import { defineSchema, defineTable } from "convex/server";  
import { v } from "convex/values";

export default defineSchema({  
  users: defineTable({  
	name: v.string(),  
	// ... other user fields ...  
  }),  
  messages: defineTable({  
	body: v.string(),  
	userId: v.id("users"),	// Reference to a user document ID  
	// ... other message fields ...  
  })  
});

In this example, *userId: v.id("users")* declares that the *messages.userId* field must be an **Id referencing a document in the "users" table***[\[18\]*](https://docs.convex.dev/database/schemas#:~:text=export%20default%20defineSchema%28,name%3A%20v.string%28%29%2C%20tokenIdentifier%3A%20v.string). Convex will ensure at runtime that any value assigned to *userId* is a valid *Id\<"users"\>* object (not just a random string).

·  	**Modeling Relations:** Because Convex is schemaless beyond the validations, there are no formal foreign key constraints or joins. Instead, you store references (as above) and manually query related data. For instance, to get a user’s messages, you might do:

const userId \= ...;  // Id\<"users"\>  
const messages \= await ctx.db.query("messages")  
               	.withIndex("by\_user", q \=\> q.eq("userId", userId))  
               	.collect();

Or, given a message, retrieve its user with *await ctx.db.get(message.userId)*. Storing Convex *Id* fields is the direct analog of foreign keys[*\[19\]*](https://docs.convex.dev/database/document-ids#:~:text=In%20Convex%2C%20you%20can%20reference,in%20another%20document)*[\[20\]](https://docs.convex.dev/database/document-ids#:~:text=const%20user%20%3D%20await%20ctx)*. You can also define secondary indexes to optimize lookups by a foreign key. In the schema above, we could add an index on *messages* by userId:

messages: defineTable({ ... }).index("by\_user", \["userId"\]),

This index makes querying all messages for a user efficient (similar to an index on a foreign key in Postgres).

* **Indexes:** Convex indexes are defined per table on specific fields or field combinations. Translate any important Postgres indexes or query patterns into Convex indexes. For example, if you frequently query Supabase for records by a *status* or by a composite key, define a Convex index for those fields. In Convex’s TypeScript schema, this looks like *.index("indexName", \["fieldName"\])* appended to a table definition[*\[21\]*](https://docs.convex.dev/database/schemas#:~:text=user%3A%20v.id%28,). Unlike Postgres, Convex does not automatically index foreign key fields, so you should add indexes explicitly for any field you will filter on (user IDs, category fields, etc.).  
* **No Joins – Data modeling considerations:** Convex queries cannot join across tables like SQL. You will often perform multiple queries: e.g. fetch a user document, then use its *\_id* to query another table. Alternatively, denormalize some data if it’s small (e.g. store a username directly in a post for quick display, while still keeping a reference for deeper data). The recommended approach is to keep documents fairly focused and use references for relationships, rather than deeply nested documents[*\[22\]*](https://docs.convex.dev/database/document-ids#:~:text=Using%20,build%20a%20complex%20data%20model). Keep an eye on document size (Convex suggests avoiding very large or deeply nested documents, instead use multiple tables and relations[*\[23\]*](https://docs.convex.dev/database/document-ids#:~:text=Trading%20off%20deeply%20nested%20documents,relationships)).  
* **Enforcing relational integrity:** Convex does not automatically enforce referential integrity (if you insert a message with a *userId* that doesn’t exist, it won’t be caught unless you check). To replicate the safety of foreign keys, you should add checks in your mutation functions. For example, in a mutation that inserts a new *message*, you might do:

const user \= await ctx.db.get(userId);  
if (\!user) throw new Error("Invalid userId");  
// then insert message

You can also use Convex **type validators** on function arguments to ensure an *Id\<"users"\>* is properly formatted before using it, or use *ctx.db.normalizeId()* to validate an arbitrary string is a valid Convex ID of the expected table[*\[24\]*](https://docs.convex.dev/database/document-ids#:~:text=function%20and%20get%20the%20corresponding,type)*[\[25\]](https://docs.convex.dev/database/document-ids#:~:text=)*.

·  	**Replacing RLS (Row-Level Security):** Supabase RLS policies restricted which rows each user could access. In Convex, you must implement those rules in code, as Convex has no built-in RLS equivalent. This is a deliberate design: *“Convex doesn’t need an opinionated authorization framework like RLS... you can build any authorization in code”[\[8\]](https://docs.convex.dev/auth#:~:text=This%20means%20Convex%20doesn%27t%20need,authorization%20framework%20for%20your%20needs)*. Concretely, for every query or mutation that should be limited by user, **check the user’s identity and role against the data**. For example, if a Supabase table had RLS “user can only SELECT their own records,” the Convex query should do something like:

const user \= await ctx.auth.getUserIdentity();  
if (\!user) throw new Error("Unauthenticated");  
return await ctx.db.query("projects")  
      	.filter(q \=\> q.eq(q.field("ownerId"), user.tokenIdentifier))  
      	.collect();

This returns only projects where *ownerId* matches the current user’s ID. For writes, verify the user is allowed to change that item (e.g. by fetching it and checking ownerId). These checks can be abstracted into helper functions (see **Security** section below) to avoid repetition. The key is that **every Convex function determines access explicitly** – if a user shouldn’t see or modify some data, your code must enforce it.

In summary, convert each Supabase table to a Convex table in *schema.ts* with appropriate fields and *v.\** types. Use Convex *Id* fields to represent foreign keys, and add indexes for any frequent lookup fields. Carefully implement any access restrictions with code checks, since the database won’t auto-restrict reads or writes.

## 3\. File Storage (Uploads & Downloads)

Supabase Storage (S3-like object buckets) will be migrated to **Convex File Storage**. Convex supports storing arbitrary files (blobs) and serving them, but the approach differs from Supabase’s direct bucket URLs. Here’s how to handle storage:

* **Enabling Convex File Storage:** Convex file storage is built-in. In your Convex project, you don’t need a separate bucket configuration – files are stored in Convex’s infrastructure and associated with a special *"\_storage"* table internally. Each stored file is referenced by a *storageId* (an *Id\<"\_storage"\>* object).  
* **Uploading Files:** Convex uses a two-step upload process for security and performance. You do **not** directly stream files through Convex functions (which have a 20 MB request size limit)[*\[26\]*](https://docs.convex.dev/file-storage/upload-files#:~:text=The%20custom%20upload%20HTTP%20action,is%20currently%20limited%20to%2020MB)*[\[27\]](https://docs.convex.dev/file-storage/serve-files#:~:text=take%20some%20parameter,or%20a%20storage%20ID%20itself)*. Instead:  
  ·  	**Generate an Upload URL:** Your app calls a Convex *mutation* like *generateUploadUrl*. This uses *ctx.storage.generateUploadUrl()* to produce a short-lived URL (valid \~1 hour) that the client can POST the file to[*\[28\]*](https://docs.convex.dev/file-storage/upload-files#:~:text=1,data%20model%20via%20another%20mutation)*[\[29\]](https://docs.convex.dev/file-storage/upload-files#:~:text=%2F%2F%20Step%201%3A%20Get%20a,%3D%20await%20result.json)*. You can restrict who can call this mutation (e.g. only logged-in users) before generating the URL.  
  ·  	**Client Uploads to URL:** The client (browser) sends the file data with a standard *fetch* or form POST to the provided URL. This uploads the file directly into Convex storage. If successful, the upload endpoint returns a JSON containing the new *storageId* for the file[*\[28\]*](https://docs.convex.dev/file-storage/upload-files#:~:text=1,data%20model%20via%20another%20mutation)*[\[29\]](https://docs.convex.dev/file-storage/upload-files#:~:text=%2F%2F%20Step%201%3A%20Get%20a,%3D%20await%20result.json)*.  
* **Store File Reference:** Finally, the client calls another Convex mutation (e.g. *saveFileMessage*) with that *storageId* to update your database. For example, you might insert a new record in a *messages* table with a field *image: Id\<"\_storage"\>*. Storing the *storageId* in your documents is analogous to storing a file path or URL in Supabase.  
* **Serving Files to Users:** There are two ways to deliver files back to the client:  
  ·  	**Generate a Public URL via Convex:** Convex can generate time-limited URLs for files. In a query function, you can call *ctx.storage.getUrl(storageId)* to get a URL string[*\[30\]*](https://docs.convex.dev/file-storage/serve-files#:~:text=const%20messages%20%3D%20await%20ctx.db.query%28,). This URL can be returned in your query response and used as the *src* in an *\<img\>* tag or an anchor link. The URL will point to Convex’s content delivery for that file. This is simple and efficient – **use this method for most files**, controlling access by only returning URLs to authorized users (the URL itself is hard to guess).  
  ·  	**Serve through an HTTP Action (for access control):** If you need to enforce authorization at the moment of download (for example, to check a user’s permissions on each file access, or to serve files with custom logic), you can create an **HTTP action** route. This is a Convex function exposed as an HTTP endpoint (e.g. */api/getFile*) that takes a file identifier and returns the file bytes conditionally. In the action, use *ctx.storage.get(storageId)* to retrieve the file blob and return an HTTP *Response* containing it[*\[31\]*](https://docs.convex.dev/file-storage/serve-files#:~:text=You%20can%20serve%20files%20directly,or%20a%20storage%20ID%20itself)*[\[32\]](https://docs.convex.dev/file-storage/serve-files#:~:text=const%20http%20%3D%20httpRouter)*. You can inspect *request.headers* or query params (like a file ID) to perform auth checks before returning the blob. Note that direct HTTP actions for files also have a \~20 MB response limit[*\[27\]*](https://docs.convex.dev/file-storage/serve-files#:~:text=take%20some%20parameter,or%20a%20storage%20ID%20itself), so large files should use the *getUrl* method instead (which streams from storage servers).

For most use cases (images, PDFs, etc. \< 20MB), a common pattern is: store *storageId* in a Convex document, and have your data query include a file URL for each *storageId*. Example:

export const listUserFiles \= query({  
  args: {},  
  handler: async (ctx) \=\> {  
	const userId \= (await ctx.auth.getUserIdentity())?.tokenIdentifier;  
	if (\!userId) throw new Error("Not logged in");  
	// Fetch file docs belonging to this user (assume we have a fileInfo table)  
	const files \= await ctx.db.query("fileInfo").filter(q \=\> q.eq(q.field("ownerId"), userId)).collect();  
	// For each file record, append a URL to include in the output  
	return Promise.all(files.map(async f \=\> ({  
  	name: f.name,  
  	url: await ctx.storage.getUrl(f.storageId)   // generate accessible URL  
	})));  
  }  
});

Here we ensure the requesting user matches the file owner before giving out the URL. The client gets an array of files with URLs and can then display or download them. **Always check authorization in the query** that provides a file URL[*\[33\]*](https://docs.convex.dev/file-storage/serve-files#:~:text=In%20your%20query%20you%20can,file%20serving%20HTTP%20actions%20instead) – if a user shouldn’t access a file, simply don’t include its URL in the response. This effectively protects the file because only authorized URLs get generated.

·  	**Migrating Existing Files:** You’ll need to move files from Supabase Storage into Convex. There’s no automatic tool, but you can do it with a script:

·  	Use Supabase API or admin UI to list and download all files from the buckets you use.

·  	For each file, call the Convex upload flow (generate URL, POST file, save storageId). You could write a Node.js script using Convex’s HTTP API or a Convex Action to batch-import files. Ensure to associate each file’s Convex *storageId* with the corresponding record in Convex DB (e.g., if you had a *profiles* table with an avatar image, update each profile in Convex with the new storageId after upload).

* Alternatively, if files are small and not too many, you might temporarily allow a Convex Action to fetch from the Supabase URL and store the file (Convex has *ctx.storage.storeUrl()* or you can fetch bytes in an action). This approach can transfer a file server-side: your action fetches the file from Supabase (which yields a Blob) and then stores that blob in Convex in one step.  
* **Access Control:** Supabase’s bucket rules (e.g. public or protected buckets) need to be translated. If files were public, you can likely serve them with Convex public URLs (just generate the URL without auth checks). If files were protected per-user, use the approach above (only give URLs to the owning user, or use an authenticated HTTP action). Convex’s approach is flexible – you can even implement per-file ACL logic in the serving query/action if needed.  
* **Cleanup and Storage Management:** Convex provides *ctx.storage.delete(storageId)* to remove files (for example, if a user replaces or deletes an upload). You should implement any necessary cleanup (Supabase might have had triggers or policies for this). You can call deletion in a Convex mutation when a user or admin deletes a file record[*\[34\]*](https://docs.convex.dev/file-storage#:~:text=,Access%20file%20metadata)*[\[35\]](https://docs.convex.dev/file-storage#:~:text=,Access%20file%20%2018)*. Also consider using Convex **cron jobs** (see below) to periodically clean up any orphaned files (files that aren’t referenced by any DB record).

**Summary:** Use Convex’s storage API to handle file uploads in a controlled way. Generate one-time upload URLs for client uploads[*\[28\]*](https://docs.convex.dev/file-storage/upload-files#:~:text=1,data%20model%20via%20another%20mutation), store the resulting *storageId* in Convex, and use *storage.getUrl()* to retrieve files for display[*\[30\]*](https://docs.convex.dev/file-storage/serve-files#:~:text=const%20messages%20%3D%20await%20ctx.db.query%28,). This gives a secure, trackable path for all file storage, replacing Supabase’s bucket URL approach. Test file upload/download thoroughly to ensure the Next.js app can send files and retrieve them from Convex.

## 4\. Edge Functions and Backend Logic

Supabase Edge Functions (server-side TypeScript functions running on Deno) should be translated into Convex **functions**. In Convex, there are three kinds of functions: **queries** (for reads), **mutations** (for writes), and **actions** (for external side-effects or long-running tasks). Also, Convex supports **HTTP actions** for creating custom webhooks or endpoints. The migration strategy:

·  	**Supabase Edge Functions triggered by HTTP (webhooks):** For any endpoint that external services call (e.g. Stripe webhooks, payment callbacks, etc.), use a **Convex HTTP Action**. Convex allows you to define an HTTP route in a special *http.ts* (or any file using *httpRouter()*). For example, to handle a Stripe webhook:

\`\`\`ts // convex/http.ts import { httpRouter } from "convex/server"; import { httpAction } from "./\_generated/server"; import { verifyStripeSignature } from "../utils"; // hypothetical utility

const http \= httpRouter();

// Define a POST endpoint for Stripe webhooks http.route({ path: "/stripe/webhook", method: "POST", // The handler can be an async function that reads the request body, headers, etc. handler: httpAction(async (ctx, request) \=\> { const body \= await request.text(); const sig \= request.headers.get("stripe-signature"); if (\!verifyStripeSignature(body, sig)) { return new Response("Bad signature", { status: 400 }); } const event \= JSON.parse(body); // Process the Stripe event (e.g., invoice.paid) await ctx.db.insert("billingEvents", { ...event }); // or call a mutation return new Response("OK"); }), });

export default http; \`\`\`

This defines an HTTP POST route at *https://\<your-deployment\>.convex.site/stripe/webhook*. You can similarly port any GET/POST endpoints from Supabase Edge Functions to Convex by defining them here. Use Convex environment variables to store secrets like signing secrets or API keys (see *Security* section) instead of hardcoding.

**Note:** HTTP actions run in a Node.js environment and are not reactive; they are meant for one-off requests from outside. The 20 MB request/response limit applies[*\[27\]*](https://docs.convex.dev/file-storage/serve-files#:~:text=take%20some%20parameter,or%20a%20storage%20ID%20itself). Within an HTTP action, you can call *ctx.db* to do inserts/updates or call other Convex functions. This covers most use cases Supabase Edge Functions handled (e.g., handling webhook and writing to DB).

·  	**Server-side computations or business logic:** If your Supabase Edge Functions were invoked by your frontend for heavy computations or privileged actions, use **Convex Mutations or Actions**. The rule of thumb:

·  	Use a **Convex mutation** if the function needs to **write to the Convex database** and doesn’t require calling external APIs. Convex mutations are ACID transactions on your data – they run completely or not at all, and Convex will automatically retry them if there are transient errors. One caveat: mutations (and queries) must be **deterministic and free of side effects** other than DB writes[*\[36\]*](https://docs.convex.dev/functions/mutation-functions#:~:text=Mutations%20,third%20party%20APIs%2C%20use%20actions). This means in a mutation you should not call third-party APIs or generate non-deterministic values without seeding (to keep replays consistent).

·  	Use a **Convex action** for tasks that involve external side-effects or long-running processes. Actions can call third-party APIs (e.g., send an email, call an external service) and perform non-deterministic operations. They are not automatically retried by Convex (since side-effects shouldn’t replay)[*\[37\]*](https://docs.convex.dev/functions/actions#:~:text=Unlike%20queries%20and%20mutations%2C%20actions,For%20example%2C%20say%20your). For example, if a Supabase Edge Function sent an email via SendGrid and then updated a record, you would implement this in Convex as an action that calls SendGrid’s API and then does *ctx.db.insert* or *patch*. Actions run outside the normal query/mutation consistency context, so if you need to update the DB as part of an action, consider that the action might succeed partially. Often the pattern is: do the external call in an action, then call a mutation (transactional) to record the result.

In Convex, you define actions similarly to mutations, using *action()* from *\_generated/server*. For example:

import { action } from "./\_generated/server";  
export const sendWelcomeEmail \= action({  
  args: { userId: v.id("users") },  
  handler: async (ctx, args) \=\> {  
	const user \= await ctx.db.get(args.userId);  
	if (\!user) throw new Error("User not found");  
	// Call external email API  
	const API\_KEY \= process.env.SENDGRID\_KEY;  
	await fetch("https://api.sendgrid.com/v3/mail/send", {  
  	method: "POST",  
  	headers: { Authorization: \`Bearer ${API\_KEY}\` },  
  	body: JSON.stringify({...})  
	});  
	// Mark user as emailed in DB:  
	await ctx.db.patch(args.userId, { welcomeEmailSent: true });  
  }  
});

This action can be invoked from your React app via the Convex client (*useMutation(api.sendWelcomeEmail)*), just like a mutation. The difference is that Convex knows not to automatically retry it on failure and that it may have side effects.

* **Converting Supabase RPC calls:** If your Next.js app was calling Supabase’s RPC (Postgres functions) or Edge Functions for certain tasks (like complex SQL logic), you will now call Convex functions. Convex provides a typed API: if you *npx convex codegen*, it generates an *api* object with all your functions. You use *useQuery(api.funcName)* for queries or *useMutation(api.funcName)* for mutations/actions in React. Under the hood, these trigger the corresponding Convex function on the backend. Ensure you update your frontend code to call Convex instead of Supabase. Because all Convex functions run on Convex servers, you no longer need a separate API route in Next.js for those calls – the Convex client handles it via WebSocket/HTTP behind the scenes.  
* **Third-Party Integrations:** Many Supabase Edge Functions likely integrated with third-party APIs (payments, analytics, etc.). As noted, do those calls in Convex actions. Keep any API keys or secrets out of the client – store them as Convex environment variables and access via *process.env* in the Convex function[*\[38\]*](https://docs.convex.dev/production/environment-variables#:~:text=Environment%20variables%20are%20key,process.env)*[\[39\]](https://docs.convex.dev/production/environment-variables#:~:text=Accessing%20environment%20variables)*. For example, set *STRIPE\_SECRET\_KEY* in Convex’s dashboard, and use *process.env.STRIPE\_SECRET\_KEY* inside the webhook handler or any action that calls Stripe.  
* **Function Organization:** Place your Convex functions in the *convex/* directory. You might mirror the structure of your Supabase functions. For instance, if you had *functions/billing.ts* in Supabase, you can have *convex/billing.ts* with mutations/actions for billing. Convex will automatically discover any exported functions. You can also mark some functions as **internal** (not callable from the client) using *internalMutation*/*internalAction* if needed – these can only be invoked by other Convex functions or crons, which is useful for helper logic you don’t want exposed on the API[*\[40\]*](https://docs.convex.dev/api/interfaces/server.Scheduler#:~:text=Interface%3A%20Scheduler%20,runAfter). Internal functions appear under an *internal* namespace in the generated API and cannot be called via *useMutation* from the app.

**Example – Broadcasting (Realtime):** Supabase offered *realtime* channels for things like broadcasts (like *supabase.channel().send()*). In Convex, you typically wouldn’t manually broadcast; instead, if you want to notify clients of an event, you would **write a record to a Convex table** and have clients subscribe to it via *useQuery*. Convex’s reactivity will push the change to clients automatically. However, if you had truly ephemeral messages (presence indicators, etc.), Convex provides a low-level API called *Convex broadcast* (currently experimental) or you can simulate it by storing ephemeral data with short TTL and querying it. Most cases can be handled by normal Convex reactivity (see Realtime section).

**Testing Converted Functions:** After implementing Convex functions to replace Supabase server logic, test them thoroughly. Use *npx convex dev* to run a dev instance and try calling the functions from your Next.js app or via the Convex CLI (*npx convex dev \--once functionName args...*). Check the Convex logs (in the dashboard or terminal) for any errors. This ensures your business logic survived the translation.

## 5\. Scheduled Jobs (Cron Tasks)

The apps have scheduled tasks (cron jobs) for things like “attendance closing” or monthly reports. Supabase might have achieved this via PG Cron, Scheduled Edge Functions, or external cron triggers. In Convex, you will use **Convex Crons** defined in a *convex/crons.ts* file.

**Setting up Cron Jobs:** Convex allows recurring invocation of functions on a schedule you define[*\[41\]*](https://docs.convex.dev/scheduling/cron-jobs#:~:text=Convex%20allows%20you%20to%20schedule,schedule%20a%20backup%20every%20Saturday). You create a *crons.ts* like so:

import { cronJobs } from "convex/server";  
import { internal } from "./\_generated/api";  // import your functions (internal or public)

const crons \= cronJobs();

// Example 1: Run every day at midnight UTC  
crons.daily(  
  "closeAttendanceDaily",  
  { hourUTC: 0, minuteUTC: 0 },  
  internal.attendance.closeAttendance,  // call an internal mutation  
);

// Example 2: Run every week on Monday at 07:30 UTC  
crons.weekly(  
  "weeklySummaryEmail",  
  { weekday: 1, hourUTC: 7, minuteUTC: 30 },  
  internal.reports.sendWeeklySummary,  
  { includeInactive: false }  // you can pass arguments to the function  
);

// Example 3: Run a job every 15 minutes  
crons.interval(  
  "syncExternalData",  
  { minutes: 15 },  
  internal.sync.fetchLatestData,  
);

// Example 4: Using cron syntax for a custom schedule – 0 16 1 \* \* \= on the 1st of each month at 16:00 UTC  
crons.cron(  
  "monthlyReportGeneration",  
  "0 16 1 \* \*",  
  internal.reports.generateMonthly,  
);

export default crons;

Each scheduled job has: \- A **unique name** (string label) – e.g. *"closeAttendanceDaily"*. \- A schedule, specified either by a convenience method (*daily*, *weekly*, etc.) or a cron expression. Convex provides helpers for common schedules like *hourly*, *daily*, *weekly*, *monthly* with clearly named fields[*\[42\]*](https://docs.convex.dev/scheduling/cron-jobs#:~:text=,creating%20schedules%20in%20this%20format). The example above shows both styles. \- A target function to call. This can be any Convex function (query, mutation, or action). Typically, you’ll point to an **internal mutation/action** that performs the task (mark attendance closed, send emails, etc.), so that normal users cannot call it manually. In code, we reference e.g. *internal.attendance.closeAttendance* which corresponds to an exported function in *convex/attendance.ts* defined with *internalMutation[\[43\]](https://docs.convex.dev/scheduling/cron-jobs#:~:text=Supported%20schedules%20below)*. You could also call a public function via the *api* import, but internal is safer for admin tasks. \- Optional arguments to pass to the function (as an object). In the weekly example, we pass *{ includeInactive: false }* to the summary function. The function signature should accept an argument of that shape.

Convex’s scheduler is robust. Once you deploy *crons.ts*, Convex will ensure these jobs run at the specified times on your production deployment. Some notes: \- **Time zones:** The scheduling fields like *hourUTC* use UTC by default. In *weekly*, *weekday: 1* is Monday, and the time is UTC. Plan accordingly if you need it aligned with a specific timezone (you might have to adjust the hourUTC or use cron expression). \- **Interval vs Cron:** *interval* jobs run relative to deployment time (first run starts immediately when deployed, then every X seconds/minutes/hours)[*\[44\]*](https://docs.convex.dev/scheduling/cron-jobs#:~:text=const%20crons%20%3D%20cronJobs). Cron-based (*cron()*, *daily()*, etc.) run at calendar times. Use *interval* for rapid or relative schedules (like “every 10 minutes”), and cron for specific times/days. \- **Examples from question:** \- *Attendance closing daily:* Use *crons.daily("closeAttendanceDaily", { hourUTC: …, minuteUTC: … }, internal.attendance.closeAttendance)*. If it needs to run at end of day local time, convert that to UTC. \- *Monthly reports:* Use *crons.monthly("monthlyReport", { day: 1, hourUTC: X, minuteUTC: Y }, internal.reports.generateMonthly)* to run on 1st of each month[*\[45\]*](https://docs.convex.dev/scheduling/cron-jobs#:~:text=crons.monthly%28%20,argument%20to%20sendPaymentEmail). Or a cron string if you need something like last day of month, etc. \- You can also schedule weekly on Fridays for weekly reports: *crons.weekly("weeklyReport", { weekday: 5, hourUTC: Z, minuteUTC: 0 }, internal.reports.generateWeekly)*.

* **Cron Job Execution:** When a cron triggers, it will invoke the specified function. If a job is still running when the next scheduled time comes, Convex will **skip** the overlapping run to avoid pile-ups[*\[46\]*](https://docs.convex.dev/scheduling/cron-jobs#:~:text=Error%20handling). So ensure your cron tasks generally finish before the next one. If a cron function throws an error, it will be logged; Convex does not retry cron jobs automatically, so include error handling or idempotency if needed (you can schedule the next run or handle partial failures inside the function).  
* **Testing and Monitoring:** You can view configured cron jobs in the Convex dashboard’s Cron Jobs section (each job with last run time, next run, etc.)[*\[47\]*](https://docs.convex.dev/scheduling/cron-jobs#:~:text=Viewing%20your%20cron%20jobs). For testing, you might temporarily set an *interval* of a few minutes or use a preview deployment to ensure the logic works. The Convex logs will show each invocation and any output or errors. During migration, consider running the Convex jobs in dev mode to simulate their behavior (or manually call the underlying function) to verify they produce the expected results (e.g., an attendance record is marked closed, an email is queued, etc.).

By moving scheduled tasks to Convex’s *crons.ts*, you eliminate the need for external schedulers or the Supabase CRON addon. All scheduling stays within your Convex project, and you can adjust timing by editing code. Make sure to **disable or remove** the old Supabase cron jobs (to avoid duplicate runs) once Convex is handling them.

## 6\. Realtime Updates and Subscriptions

Both Supabase and Convex support realtime data updates but via different paradigms. Supabase achieves realtime either through PostgreSQL replication (broadcasting table row changes) or the Realtime server channels (for presence and broadcasts). Convex takes a more declarative approach: **queries are reactive** – clients automatically get updates when the underlying data changes. We will replace Supabase realtime features with Convex’s reactivity and Next.js’s new data-fetching patterns.

**Convex Reactive Queries:** In Convex’s React client, you use hooks like *useQuery* to fetch data. These queries stay live – if any data that the query result depends on changes (due to a Convex mutation from any client), the Convex backend pushes an update and the *useQuery* hook triggers a re-render with new data[*\[48\]*](https://www.reddit.com/r/nextjs/comments/1juhpvg/yall_sleeping_on_convex/#:~:text=You%20use%20them%20directly%20in,hooks%20allow%20seamless%20interaction). This means you no longer need to manually set up listeners on database changes or use *onSnapshot* style callbacks. Simply fetch the data and let Convex handle subscriptions under the hood. For example:

const tasks \= useQuery(api.tasks.list, { projectId: currentProjectId });

If another user adds a task or a status changes (via a Convex mutation), everyone with this query subscribed will get the updated *tasks* array almost instantly. This replaces Supabase’s *on().subscribe()* for live queries. You should ensure that your queries are written to return *exactly* the data each component needs (with appropriate filtering by user or project), so that the reactivity is scoped and efficient.

**Realtime Presence or Broadcasts:** If the apps used Supabase’s *realtime.channel()* for something like chat messages or user presence, the equivalent in Convex is to model that data in Convex as well: \- *Chat messages:* Use a Convex table for messages and a query like *api.chat.latestMessages* that returns messages for a room, limited to the last N. With *useQuery*, new messages (inserted via Convex mutation) will automatically appear for all subscribers. \- *User presence (online/offline):* You can maintain a Convex table of “online users” and update it via mutations (perhaps using a periodic ping or Convex’s *onConnectionClosed* API to remove users on disconnect). Then use a query to list online users. This is more manual than Supabase’s built-in broadcast but gives you full control. (Convex doesn’t yet have a high-level presence API, but the data model approach works for up to thousands of users.)

**Next.js App Router and SSR:** Next.js 13+ App Router introduces server components and new ways to fetch data. Convex provides integration to use its reactive queries with Next’s SSR: \- **Client vs Server Components:** Convex’s *useQuery* can **only be used in Client Components**, because it establishes a live connection (WebSocket) to listen for changes[*\[49\]*](https://docs.convex.dev/client/nextjs/app-router/#:~:text=To%20keep%20your%20UI%20automatically,must%20happen%20on%20the%20client)*[\[50\]](https://docs.convex.dev/client/nextjs/app-router/#:~:text=it%20needs%20to%20use%20Client,must%20happen%20on%20the%20client)*. In a Server Component, you can’t maintain that reactive connection. Therefore, any component that calls *useQuery* must be marked with *"use client"* and likely wrapped in a Convex provider. \- **Preloading Data for SSR:** To avoid a blank loading state on first load, Convex offers a *preloadQuery* function for Next.js. In a Server Component (or a Next.js Page *generateStaticParams* or similar), you can call *await preloadQuery(api.someQuery, args)[\[51\]](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=Preloading%20data%20for%20Client%20Components)[\[52\]](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=import%20,Tasks)*. This will perform the query on the server at request time and embed the result in the HTML. Then, in a corresponding Client Component, you use *usePreloadedQuery(preloadedData)* to hydrate and subscribe to updates[*\[53\]*](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=In%20a%20Client%20Component%20call,usePreloadedQuery)*[\[54\]](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=export%20function%20Tasks%28props%3A%20,div%3E%3B)*. This pattern gives the best of both: the page is rendered with data (no flicker), and then it continues updating in real-time on the client.

**Example:** Suppose the dashboard page needs to show the current month’s report (which updates in real-time as data comes in). You could do:

// app/reports/page.tsx – a server component  
import { preloadQuery } from "convex/nextjs";  
import { api } from "@/convex/\_generated/api";  
import ReportsClient from "./ReportsClient";  // client component

export default async function ReportsPage() {  
  const preloaded \= await preloadQuery(api.reports.currentMonth, {});  
  return \<ReportsClient preloadedReports={preloaded} /\>;  
}

And in *ReportsClient.tsx*:

"use client";  
import { usePreloadedQuery, useMutation } from "convex/react";  
import { api, type Report } from "@/convex/\_generated/api";

export default function ReportsClient({ preloadedReports }) {  
  const report: Report \= usePreloadedQuery(preloadedReports);  
  const finalizeReport \= useMutation(api.reports.finalize);

  // ... render the report, perhaps with a button to finalize  
  // The report object will live-update if data changes  
  // finalizeReport can be called to trigger a mutation  
}

This approach ensures the data is loaded on the server for initial paint[*\[55\]*](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=If%20you%20want%20to%20preload,preloadQuery%20%20from%20%2050), and then *usePreloadedQuery* turns it into a live subscription on the client[*\[56\]*](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=import%20,convex%2F_generated%2Fapi).

·  	**SSR for Authenticated Data:** If a page requires authentication and you want to fetch Convex data server-side, you’ll need to integrate the auth token on the server. For example, using NextAuth, you might use the NextAuth server session to get a user and then pass their token to Convex’s *fetchQuery* or *preloadQuery*. Convex has *fetchQuery(api.func, args)* which is like preload but for one-time fetch (non-reactive) in a Server Component[*\[57\]*](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=Using%20Convex%20to%20render%20Server,Components). Keep in mind that without the live connection, server-fetched data won’t update until a client subscribes or a refresh happens.

**Updating UI with Convex:** To trigger updates, use **Convex mutations** from the client via *useMutation*. This is analogous to calling Supabase’s *.insert()* or *.update()*, but the difference is you don’t manually emit any events – once the mutation writes to the database, any relevant *useQuery* subscriptions on any client will get the new data. This simplifies your client logic: no need for explicit *.on('change')* listeners.

**Cleanup Supabase Realtime Artifacts:** Remove any Supabase realtime subscriptions in your code (e.g. *supabase.channel('...').on('postgres\_changes', ...)*). They won’t be needed. Instead, ensure your components are using Convex queries for any data that was being listened to. If you had some global listener (like “notify user if they’ve been mentioned”), consider modeling it as part of user’s notification state in Convex and subscribing to that.

Finally, test the real-time flow: open two browsers and perform actions, ensure data updates propagate correctly via Convex. Convex’s real-time updates are quite fast (on the order of tens of milliseconds). The Next.js App Router and Convex integration should give you SSR and reactive hydration out of the box, providing a seamless real-time UX.

## 7\. Data Migration (Moving Data from Supabase to Convex)

Migrating data is a one-time but critical step. We need to export all existing data from Supabase and import it into Convex’s database. Since Supabase is PostgreSQL, you have a few options to export: \- Use the Supabase CLI or Dashboard to **export each table as CSV** (the dashboard has an “Export” option for tables to CSV). \- Use *pg\_dump* (via Supabase CLI *supabase db dump*) to get a full SQL export. You would then convert that to CSV/JSON. \- Use Supabase’s APIs or a script to fetch all rows and transform to JSON.

Convex provides a data import tool that accepts **CSV, JSON, or JSONL** files for each table[*\[58\]*](https://docs.convex.dev/database/import-export/import#:~:text=Import%20a%20CSV%2C%20JSON%2C%20or,file%20into%20a%20Convex%20table). The general process: 1\. **Export from Supabase:** For each table, get the data in a structured form (CSV or JSON). For example, export *users*, *projects*, *tasks*, etc. 2\. **Transform to Convex-friendly format:** Convex JSON import expects an array of objects (for *.json*) or one JSON object per line (for *.jsonl*). If using CSV, ensure the header names match your Convex schema field names. Also, data types: Convex will try to infer number vs string from CSV, so strings should be quoted. For JSON, ensure the field types align (e.g. boolean values as true/false, dates can be as numeric timestamps or ISO strings if you plan to store as string). \- **IDs:** The tricky part is foreign keys. In the Supabase data, you might have *user\_id* in a tasks CSV as an integer or UUID referencing users. In Convex, that needs to become an *Id\<"users"\>* object. Convex’s import tool cannot magically connect those, so we have to handle it. There are two strategies: \- **Strategy A: Preserve IDs by manual mapping:** You can include the Convex *\_id* field in your import data to set specific Convex IDs[*\[59\]*](https://docs.convex.dev/database/import-export/import#:~:text=Features). Convex IDs are strings like "*{tableName}\_{random}*" (actually Convex will generate an appropriate unique string). If Supabase’s user IDs are UUIDs, you might try to use those as Convex *\_id* for the user table (Convex IDs must be 15+ character alphanumeric strings; some UUIDs might work if formatted correctly, but this is not officially documented). A safer approach is to import without forcing IDs, then map foreign keys: \- Import the **users** table first. Let Convex assign each a new *\_id*. \- After import, create a mapping between the old Supabase user ID and the new Convex *\_id*. For example, if you had an *oldUserId* field (numeric) in the JSON, after import iterate through Convex *users* and build an object *{oldId \-\> convexId}*. \- Next, when importing related tables (tasks, etc.), replace the foreign key field with the Convex Id. You could do this by editing the JSON/CSV: e.g., in tasks JSON, instead of *"user\_id": 42*, put *"userId": "\<convexIdString\>"* using the mapped value. Then import tasks. Because Convex’s import with JSON will interpret a string in an *v.id("users")* field as an Id (it must match the format, otherwise you might need to later normalize it). \- This is somewhat involved if done manually. Instead, you could import the raw foreign keys into a temp field (like *legacyUserId* as a number), then run a Convex migration function to populate the real *userId* field: the function would scan each task, find the user with that legacy ID (which might require storing a mapping table in Convex), and patch the task with *userId*. \- **Strategy B: Use Convex Backup/Restore with custom IDs:** Convex’s *npx convex import \<backup.zip\>* can preserve IDs and references if the backup file was created from Convex[*\[60\]*](https://docs.convex.dev/database/import-export/import#:~:text=Import%20from%20a%20Backup%20into,references%20between%20tables%20are%20maintained). But since you are coming from Supabase, you don’t have a Convex backup. However, you could potentially write a script to generate a Convex backup JSON structure with your data and desired IDs. This is advanced and probably not necessary for \<1000 users – easier is scripting via the Convex client API. \- **Strategy C: Programmatic import:** Instead of using the CLI for everything, consider using a Node script or the Convex JavaScript client to migrate data. For example, write a Node script that loads all Supabase data (via Supabase client or CSV files) and then calls Convex mutations to insert them. This way, you can use real Convex *Id* objects and logic to link references. The downside is it’s slower (each insertion is a separate call unless you batch in actions). But for a few thousand records it might be fine. This approach also lets you transform data (e.g. combine fields, hash passwords if moving auth data, etc.) with full control.

Given the simplicity of using the CLI with JSON, a reasonable plan: \- Export each table to a JSON or CSV. \- For each table, create a JSONL file (one JSON object per line) for import. JSONL handles large data better than a giant JSON array[*\[61\]*](https://docs.convex.dev/database/import-export/import#:~:text=,data.jsonl). \- Start with tables that have no dependencies (e.g. *users*). \- Import with *npx convex import \--table users users.jsonl* for example. This will upload to your Convex dev (or specify *\--prod* for production)[*\[62\]*](https://docs.convex.dev/database/import-export/import#:~:text=Single%20table%20import). \- After importing users, fetch the mapping of old to new IDs. You could export the Convex *users* table back out (Convex CLI can do *convex export*) or query it in dev. \- Use that mapping to replace foreign keys in the JSONL for dependent tables. Repeat import for those tables. Use *\--append* or *\--replace* as appropriate if you need to rerun the import (by default, import fails if table isn’t empty, to avoid duplicates[*\[63\]*](https://docs.convex.dev/database/import-export/import#:~:text=Imports%20into%20a%20table%20with,the%20table%20with%20your%20import)). \- Validate that the number of records matches and spot-check some data.

**Related data concerns:** \- **Sequences/auto-increments:** If Supabase used serial IDs, Convex will generate its own unique IDs. You don’t need to carry over sequence counters. \- **Default values:** If any fields had defaults that aren’t present in data, ensure Convex functions handle missing fields or set up the same default in code when inserting new data going forward. \- **Data types:** Convex supports numbers, strings, booleans, JSON objects/arrays, and also *BigInt* (for 64-bit ints) if needed. If you have a Postgres *timestamp* or *timestamptz*, you might convert it to a number (epoch millis) or ISO string. Convex has no date type, so choose a representation (number is often easiest). If you have enums, represent them as strings or use Convex’s *v.literal* union types for validation[*\[64\]*](https://docs.convex.dev/database/schemas#:~:text=defineTable%28%7B%20oneTwoOrThree%3A%20v.union%28%20v.literal%28,%29%2C). \- **Large text/binary:** If some columns stored large blobs, consider if they should be moved to Convex File Storage instead. For example, if Supabase had a *files* table with binary data, better to upload those to Convex storage as described above, and just import metadata.

After importing, run your Convex app in dev and query some data to ensure it’s all present. You can use the Convex Dashboard Data browser to inspect tables. Convex’s dashboard also has a “Generate Schema” from data feature which can guess a schema from imported data[*\[65\]*](https://docs.convex.dev/database/schemas#:~:text=Generating%20a%20Schema) – a handy way to verify that data types came through as expected.

**Migrating User Auth Data:** If using an external auth (Clerk/Auth0), you might not need to migrate user passwords at all (since those services hold credentials). But if you used Supabase email/password auth and plan to switch to Convex Auth (beta) or another system, migrating passwords is non-trivial (Supabase uses bcrypt hashing by default). In such a case, you might opt to force password reset for users or import hashes into a Convex table if Convex Auth can use them (likely not directly). If using external auth (recommended), you’ll just import basic user profile info (email, name) into Convex if needed for your app’s use (or rely on the external auth’s user store).

**Verify relational links:** Once data is in Convex, write a few Convex queries to ensure references align. For example, pick a sample task and do *ctx.db.get(task.userId)* to see that it finds the correct user. Also ensure no data was missed (counts match, etc.).

It’s wise to run the migration initially in a **testing environment** (perhaps a separate Convex project or the dev deployment) and test the app thoroughly against Convex with migrated data. Once satisfied, you can import into production Convex. Keep the Supabase read-only during the final cut-over so you don’t have new data coming in after export.

## 8\. Security and Authorization in Convex

Security in Convex is implemented in application logic. Supabase relied on RLS policies, storage rules, etc., whereas Convex expects you to enforce permissions explicitly. Here’s how to rebuild a robust authz layer:

* **Centralize Authorization Logic:** Define helper functions or modules for permission checks. For example, create a file *convex/permissions.ts* where you export functions like:  
      export async function ensureProjectMember(ctx: MutationCtx, projectId: Id\<"projects"\>) {  
    const user \= await ctx.auth.getUserIdentity();  
    if (\!user) throw new Error("Unauthenticated");  
    const membership \= await ctx.db.query("projectMembers")  
                     	.filter(q \=\> q.eq(q.field("projectId"), projectId))  
                     	.filter(q \=\> q.eq(q.field("userId"), user.tokenIdentifier))  
                     	.first();  
    if (\!membership) throw new Error("Access Denied");  
    return user.tokenIdentifier; // return user ID for convenience  
  }  
               	Then in any function that requires the user to be a member of the project, call *ensureProjectMember(ctx, projectId)* at the top. This pattern prevents code duplication and ensures consistency. You could have variations like *ensureAdmin(ctx)*, *ensureOwner(ctx, resourceId)*, etc., based on your app’s roles.  
* **Use Convex’s *internalMutation*/*internalAction* for sensitive operations:** Mark functions that should never be called from the client as internal. For instance, an *deleteUserAccount* mutation that admins use, or a *recountStatistics* action used by crons, could be internal. When you define a function, use *internalMutation()* from Convex instead of *mutation()* – this means the function won’t be exposed via the normal API to the client[*\[66\]*](https://gist.github.com/srizvi/966e583693271d874bf65c2a95466339#:~:text=,). It can only be invoked by other server functions (or crons). In codegen, these appear under *internal* namespace as we saw in the cron examples. This adds a layer of safety that even if a user tampered with the client, they couldn’t directly call those routines.  
* **Replicating RLS:** As described earlier, the typical approach is to check *ctx.auth.getUserIdentity()* and the user’s privileges at the start of each function[*\[67\]*](https://docs.convex.dev/auth#:~:text=That%20said%2C%20the%20most%20common,beginning%20of%20each%20public%20function). The Convex docs explicitly encourage this approach in lieu of row-level security. For example:  
      export const updateProfile \= mutation({  
    args: { userId: v.id("users"), profileData: v.object({...}) },  
    handler: async (ctx, args) \=\> {  
  	const identity \= await ctx.auth.getUserIdentity();  
  	if (\!identity) throw new Error("Not logged in");  
  	if (identity.tokenIdentifier \!== args.userId.id) {  
    	throw new Error("Cannot edit another user's profile");  
  	}  
  	// proceed to update since it's the user's own profile  
  	await ctx.db.patch(args.userId, args.profileData);  
    }  
  });  
               	In this snippet, we ensure the caller’s ID matches the profile being edited. In Supabase RLS, this was probably a policy like *user\_id \= auth.uid()*. Now it’s enforced in code.  
* **Guarding File Access:** If you have files that only certain users can access, don’t return *ctx.storage.getUrl* for those files unless the user passes your checks. Alternatively, require a file to be fetched through an HTTP action that checks permissions each time. For instance, an HTTP action could check *req.auth* (Convex allows you to secure HTTP actions by requiring a Bearer token in the request which you can verify with *ctx.auth.getUserIdentity()* inside the action[*\[68\]*](https://docs.convex.dev/auth/functions-auth#:~:text=HTTP%20Actions)). For simplicity, generating URLs in authorized queries is usually sufficient – just be mindful to never expose a file’s URL to an unauthorized party.  
* **Environment Secrets:** Keep secrets out of code. Use Convex environment variables (set via Convex dashboard or CLI) for API keys, webhook secrets, etc. Access them with *process.env.MY\_KEY* inside functions[*\[38\]*](https://docs.convex.dev/production/environment-variables#:~:text=Environment%20variables%20are%20key,process.env)*[\[39\]](https://docs.convex.dev/production/environment-variables#:~:text=Accessing%20environment%20variables)*. Convex environment vars are not exposed to the client and can differ between dev/prod. For example, store a *MAPS\_API\_KEY* in Convex and use it in an action that calls the Maps API. This is analogous to using Supabase Secrets for Edge Functions.  
* **Validation:** Use Convex’s *v* validators for **arguments** to functions, not just for schema. For each mutation/query, define an *args* schema (e.g. *{ email: v.string() }*). This ensures the inputs are of expected type and helps avoid injection or bad data. Supabase Edge Functions might have validated inputs manually; with Convex *args* and *v* you get this structured validation out of the box. If a validation fails, the function will not run.  
* **Testing authorization:** After implementing, test security with various scenarios:  
  ·  	Call functions as a user who shouldn’t have access and ensure you get errors (and no data leakage).  
  ·  	Try to fetch data that isn’t yours via queries (the query should return empty or throw).  
  ·  	If using the Convex dashboard Data view during development, note that it bypasses your function code – it’s like directly inspecting the DB. But all client access must go through functions where your checks live, so focus testing on those functions.

By constructing explicit checks and using internal vs public functions appropriately, you’ll recreate (and even strengthen) the security model from Supabase. The benefit is that all rules are now in TypeScript, alongside your business logic, which is easier to reason about and test with unit tests.

## 9\. Testing, Verification, and Observability

Migrating to Convex is a significant change – you must verify that all features still work as expected. We strongly recommend a period of dual-running or at least extensive testing before decommissioning Supabase. Key testing and observability steps:

* **Automated Testing with Convex:** Convex supports writing unit and integration tests for your functions. You can use the *convex-test* library to simulate a Convex backend in memory and call your functions with different scenarios[*\[69\]*](https://docs.convex.dev/testing#:~:text=%60convex). For example, using Vitest or Jest, you can create a fake context and test that *createInvoice* mutation fails if user not admin, etc. Additionally, Convex offers a **Local Backend** (open-source) if you want to run a real Convex server locally for tests[*\[70\]*](https://docs.convex.dev/testing#:~:text=Testing%20against%20a%20real%20backend), though for most, the cloud dev environment suffices.  
* **Function-by-Function Verification:** Go through each piece of functionality from the Supabase era and test it on Convex:  
  ·  	Can users sign up, log in, and is their session recognized in Convex (test *ctx.auth* presence)?  
  ·  	Perform a full CRUD flow: create some data via Convex mutation, read it via Convex query (possibly reactive), update it, delete it. Ensure the changes reflect properly on all clients.  
  ·  	Test file uploads and downloads in a staging environment to confirm the 3-step upload works and images load via the new URLs.  
  ·  	Trigger the cron jobs manually if possible (Convex dashboard allows running a function directly in the dev console, or you can temporarily change a cron to interval 1 minute for quick test). Check that scheduled tasks produce the expected outcome (e.g., a report row is created).  
* If you implemented webhooks in Convex, simulate them. For instance, use curl or Postman to POST to your Convex HTTP endpoint with sample data and verify Convex processes it correctly (and returns the correct response).  
* **Observability – Logs and Dashboard:** Convex provides a real-time log stream of all function calls. In the Convex dashboard’s **Logs** section, you can see every query, mutation, action, and cron execution along with console logs and errors[*\[71\]*](https://docs.convex.dev/functions/debugging#:~:text=The%20Convex%20backend%20also%20automatically,errors%20thrown%20by%20your%20functions)*[\[72\]](https://docs.convex.dev/functions/debugging#:~:text=1,logs%2C%20which%20only%20prints%20logs)*. Leverage this heavily during testing:  
  ·  	Insert *console.log* statements in critical functions to output the flow and important variables[*\[73\]*](https://docs.convex.dev/functions/debugging#:~:text=During%20development%20the%20built,going%20on%20inside%20your%20functions)*[\[74\]](https://docs.convex.dev/functions/debugging#:~:text=,console.trace)*. For example, log when a cron runs and how many records it affected. These logs will show up in the dashboard (and in your browser dev console during *convex dev* for development deployments).  
  ·  	Watch for any errors in the logs. If a Convex function throws an uncaught error, it will be logged along with a Request ID[*\[71\]*](https://docs.convex.dev/functions/debugging#:~:text=The%20Convex%20backend%20also%20automatically,errors%20thrown%20by%20your%20functions)*[\[75\]](https://docs.convex.dev/functions/debugging#:~:text=To%20find%20the%20appropriate%20logs,request_id)*. Use that ID to search the logs for full context of what happened. The Convex dashboard even allows filtering by Request ID or function name to find relevant logs.  
* You can also stream logs to your terminal with *npx convex logs* for a prod deployment, or integrate with services like LogRocket or Sentry by forwarding logs (Convex has guides for log streaming to external destinations[*\[76\]*](https://docs.convex.dev/functions/debugging#:~:text=1,of%20your%20backend%20to%20production)).  
* **Performance Monitoring:** In the Convex dashboard, you can see performance metrics for each function call (execution time, etc.) and the rate of calls. After migration, monitor if any query is particularly slow or chatty. Perhaps an index is missing if a query is slow – you can add it and redeploy. With under 1000 users, performance should be fine, but it’s good to check for any N+1 query patterns or overly frequent function calls (Convex will show if functions are being called extremely often, which might indicate a logic issue).  
* **Parity Testing:** It’s useful to run the old Supabase version and the new Convex version side by side on some staging data to compare outcomes. For example:  
  ·  	Create a new item in Supabase app, create same in Convex app, and compare that both appear in respective databases.  
  ·  	If you have calculations (like monthly financial totals), run the calculation in both backends and compare results.  
* Ensure that no functionality is missing in the Convex version (maybe a less-used feature could be overlooked in migration).  
* **Gradual Rollout / Preview Deploys:** Convex allows **Preview deployments** which are like ephemeral environments for each Git branch. If you deploy your Convex functions from a feature branch, you get an isolated backend (with its own URL and database)[*\[77\]*](https://docs.convex.dev/database/import-export/import#:~:text=1,sample%20data)*[\[78\]](https://docs.convex.dev/database/import-export/import#:~:text=3,the%20root%20of%20the%20repo)*. You could use this to test the Convex migration in a preview attached to a Vercel preview deployment of the Next.js app. This way, testers (or AI QA agents) can test the app with Convex without affecting production. Once approved, you can promote Convex changes to production.  
* **Client-side Testing:** Because your Next.js app is largely generated by LLMs and changing to use Convex, do a thorough QA pass on the frontend. Look for:  
  ·  	Missing or incorrect updates (e.g., after an update mutation, does the UI reflect it? It should thanks to reactive queries).  
* Error handling: if a Convex function throws an error (e.g., “Access Denied”), ensure the app catches it – Convex will throw an exception to the client in that case. Your components using *useMutation* can catch errors or you might use a global error boundary.  
* **Continuous Integration:** Integrate Convex into your CI pipeline. You can write tests that spin up *convex dev* (or use the *convex-test* in-memory) to run backend tests on every commit. Also, consider using Convex’s GitHub Action for deploying to Convex and seeding data. Convex’s official guidance shows how to run tests in CI and even how to use a **local Convex backend** for testing purposes[*\[79\]*](https://docs.convex.dev/testing#:~:text=Set%20up%20testing%20in%20CI)*[\[80\]](https://docs.convex.dev/testing#:~:text=It%27s%20a%20good%20idea%20to,run%20them%20with%20GitHub%20Actions)*.

Remember, Convex is a different paradigm – make sure to test things like **offline scenarios** (Convex has built-in offline queuing; if the user is offline and calls a mutation, it queues until reconnect). This is something Supabase didn’t handle out of the box. It could be a bonus that your app gains offline resilience with Convex, but test that queueing doesn’t cause double actions or other issues in your usage.

Finally, once you are confident in testing, you can proceed to fully switch over. Expect to monitor logs in production closely in the initial days and have a rollback plan (below) just in case.

## 10\. Decommissioning Supabase and Rollback Plan

After migrating all features and data to Convex and verifying the Next.js apps work correctly, you’ll want to shut down Supabase resources to reduce cost and complexity. A cautious approach is recommended:

* **Freeze Writes to Supabase:** During the final migration cut-over, put the Supabase backend in a read-only state if possible. This could mean disabling the app’s access (perhaps by changing API keys or stopping the app) while you do the final data export. Supabase doesn’t have a straightforward “read-only mode,” but you can achieve it by temporarily revoking service\_role keys or using RLS to prevent inserts/updates for everyone. The goal is to ensure no new data enters Supabase once you’ve migrated to Convex.  
* **Final Backup of Supabase:** Before shutting anything down, take a **full backup** of your Supabase database. Use the Supabase CLI or dashboard to create a dump file (e.g., *supabase db dump* which uses pg\_dump to produce an SQL file)[*\[81\]*](https://supabase.com/docs/guides/platform/backups#:~:text=Backup%20process%20). This is your safety net. Also, if you have Supabase Storage, consider downloading all files or backing up the storage bucket (Supabase doesn’t include storage objects in the DB backup[*\[82\]*](https://supabase.com/docs/guides/platform/backups#:~:text=Database%20backups%20do%20not%20include,have%20been%20deleted%20since%20then)). If you migrated files to Convex, you likely already have them, but double-check in case any were missed.  
* **Deploy Convex and Switch the App:** Make sure your Next.js apps are now pointing to Convex. This usually means updating environment variables like *NEXT\_PUBLIC\_CONVEX\_URL* (provided when you did *npx convex init*). Also remove Supabase URLs/keys from env. Deploy the updated app to Vercel (or your hosting). The Convex project should be in production mode for the live app (Convex dev mode is for local testing only).  
* **Monitor Behavior:** Once the app is live on Convex, closely monitor logs and user feedback. It’s wise to do this during a low-traffic period. If anything catastrophic happens, you can consider rolling back (instructions below). If things look good after some time (a few hours or days), proceed to fully decommission.  
* **Shut Down Supabase Project:** This entails:  
  ·  	Disabling or deleting Supabase Edge Functions (so they don’t accidentally run).  
  ·  	Removing any scheduled tasks in Supabase (if any).  
  ·  	If you want, you can put up a small barrier in Supabase to ensure if somehow a request goes there, it doesn’t modify data. For example, leave RLS enabled for all tables with *false* condition so no reads/writes occur (in case some part of the app accidentally still calls Supabase, it will fail rather than create divergence).  
  ·  	Ultimately, if everything is confirmed on Convex, you can **delete the Supabase project**. Before deletion, **export** all data (which you did) and possibly store the backup securely (Supabase backups in their system will vanish on deletion[*\[83\]*](https://supabase.com/docs/guides/platform/backups#:~:text=Once%20a%20project%20is%20deleted,be%20carefully%20considered%20before%20proceeding)).  
* Also, consider exporting the Supabase configuration (SQL schemas) for your records, though likely not needed once moved.  
* **Convex Backups:** Now that Convex is your source of truth, set up Convex’s own backup routines. Convex automatically takes periodic backups which you can download from the dashboard, but you might also use the *convex export* command to snapshot data, or connect an Airbyte to sync to a warehouse for long-term storage. This ensures you have a way back if Convex ever has an issue or if you later need to migrate again.

**Rollback Plan:** Even with testing, have a plan if something goes wrong after switching to Convex: \- The simplest rollback is to **re-deploy the previous version** of the Next.js app that still points to Supabase, and resume using Supabase data. Because users might have created new data in Convex in the interim, a decision is needed: either freeze Convex writes and manually merge new data back into Supabase, or accept some data loss (if window is small and not critical). If you kept Supabase running in parallel (not recommended for too long, as it could diverge), you could attempt to sync Convex changes to Supabase via an export from Convex (Convex can export to JSON/CSV similarly) and an import into Postgres. This is non-trivial, especially with different schemas and IDs. \- A less drastic rollback could be to fix forward in Convex (Convex allows hotfixes). If a specific function is broken, you can deploy a fix quickly. As long as the data is intact, users might not notice beyond some errors. \- Thus, rollback usually would mean downtime: disable Convex app, bring Supabase app back up, re-import any lost data. Given the small user count (\<1000), you might communicate maintenance to users if needed.

In practice, if you’ve tested thoroughly, a rollback is unlikely. But keeping the Supabase backup means you could even spin up a new Supabase instance and restore data to it if you had to return months later. Treat that backup as the ultimate fallback.

Finally, once you’re confident, you can remove Supabase-related code from your repository (Supabase client initialization, old queries, etc.), clean up environment variables, and celebrate the migration. All ongoing development can now happen with Convex as the backend.

---

**Environmental Variables and Project Setup Recap:** Each Next.js app now has its own Convex project (since you want separate setups). Ensure you have configured: \- *NEXT\_PUBLIC\_CONVEX\_URL* (the client URL for Convex deployment) in the app’s *.env.local* (and in Vercel env vars for production). You get this URL from *convex dashboard* or when you ran *npx convex deploy* – it looks like *https://\<your-project\>.convex.cloud*. Convex also provides a *.env.local* during development automatically[*\[84\]*](https://github.com/get-convex/convex-backend/issues/191#:~:text=Convex%20CLI%20always%20creates%20,the%20required%20environment%20variables). \- If using an auth provider: the provider’s keys (e.g., Clerk publishable and secret keys, or NextAuth secrets) in the environment. \- Any third-party API keys (Stripe, etc.) should be set in Convex environment (via Convex dashboard under Deployment Settings)[*\[85\]*](https://docs.convex.dev/production/environment-variables#:~:text=Setting%20environment%20variables)*[\[86\]](https://docs.convex.dev/production/environment-variables#:~:text=Environment%20variables%20can%20also%20be,modified%20with%20the%20command%20line)* and possibly also in Next.js if the Next side calls them. Keep naming consistent (e.g. both Convex and Next use *STRIPE\_API\_KEY* with respective values). \- Each Convex project (for each app) likely has its own deployment URL and env variables. Double-check you didn’t accidentally mix them – e.g., the *ipupy\_tesoreria* app’s Convex URL goes into that app’s config, and same for *AENA\_Admin*. The Convex CLI will manage separate *.env.local* for each if they are separate repos. If they were monorepo, you’d handle it differently, but given they are separate, just be mindful when running *convex deploy* that you’re using the correct project for each.

By following this guide feature by feature, you’ll migrate off Supabase completely. The result will be two Next.js applications backed by Convex’s real-time database, with authentication handled via Convex \+ your chosen provider, file storage in Convex, and scheduled tasks and webhooks all running on Convex. All code is now in TypeScript (Convex functions) and can be AI-generated with these clear specifications, making the migration feasible and maintainable.

---

[*\[1\]*](https://docs.convex.dev/auth#:~:text=Convex%20is%20compatible%20with%20most,OAuth%20endpoints%20to%20verify%20them) [*\[2\]*](https://docs.convex.dev/auth#:~:text=,to%20be%20used%20for%20authentication) [*\[5\]*](https://docs.convex.dev/auth#:~:text=For%20client,access%20codes%2C%20or%20via%20passwords) [*\[6\]*](https://docs.convex.dev/auth#:~:text=Convex%20Auth%20is%20in%20beta) [*\[8\]*](https://docs.convex.dev/auth#:~:text=This%20means%20Convex%20doesn%27t%20need,authorization%20framework%20for%20your%20needs) [*\[67\]*](https://docs.convex.dev/auth#:~:text=That%20said%2C%20the%20most%20common,beginning%20of%20each%20public%20function) Authentication | Convex Developer Hub

[*https://docs.convex.dev/auth*](https://docs.convex.dev/auth)

[*\[3\]*](https://stack.convex.dev/nextauth-adapter#:~:text=) [*\[4\]*](https://stack.convex.dev/nextauth-adapter#:~:text=56%20const%20authTables%20%3D%20,64%20%20verificationTokens%3A%20defineTable%28verificationTokenSchema%29.index) [*\[12\]*](https://stack.convex.dev/nextauth-adapter#:~:text=7%20export%20const%20userSchema%20%3D,16%20%20expires%3A%20v.number) [*\[13\]*](https://stack.convex.dev/nextauth-adapter#:~:text=53%20%20transports%3A%20v.optional%28v.string%28%29%29%2C%2054,providerAccountId) [*\[14\]*](https://stack.convex.dev/nextauth-adapter#:~:text=15%2016%20const%20adapterQuery%20%3D,mutation%2C) [*\[15\]*](https://stack.convex.dev/nextauth-adapter#:~:text=25%20%20args%3A%20,30) Convex Adapter for Auth.js (NextAuth) Setup Guide

[*https://stack.convex.dev/nextauth-adapter*](https://stack.convex.dev/nextauth-adapter)

[*\[7\]*](https://docs.convex.dev/auth/functions-auth#:~:text=%2F%2F%20...%20,%7D) [*\[16\]*](https://docs.convex.dev/auth/functions-auth#:~:text=The%20UserIdentity%20object%20returned%20by,JWT%20tokens%20and%20OpenID%20scopes) [*\[17\]*](https://docs.convex.dev/auth/functions-auth#:~:text=,definition%20in%20the%20OpenID%20docs) [*\[68\]*](https://docs.convex.dev/auth/functions-auth#:~:text=HTTP%20Actions) Auth in Functions | Convex Developer Hub

[*https://docs.convex.dev/auth/functions-auth*](https://docs.convex.dev/auth/functions-auth)

[*\[9\]*](https://docs.convex.dev/client/nextjs/app-router/#:~:text=const%20convex%20%3D%20new%20ConvexReactClient%28process) [*\[10\]*](https://docs.convex.dev/client/nextjs/app-router/#:~:text=cacheLocation%3D,Auth0Provider%3E%20%29%3B) [*\[11\]*](https://docs.convex.dev/client/nextjs/app-router/#:~:text=To%20access%20user%20information%20or,provided%20by%20Clerk%20and%20Auth0) [*\[49\]*](https://docs.convex.dev/client/nextjs/app-router/#:~:text=To%20keep%20your%20UI%20automatically,must%20happen%20on%20the%20client) [*\[50\]*](https://docs.convex.dev/client/nextjs/app-router/#:~:text=it%20needs%20to%20use%20Client,must%20happen%20on%20the%20client) Next.js | Convex Developer Hub

[*https://docs.convex.dev/client/nextjs/app-router/*](https://docs.convex.dev/client/nextjs/app-router/)

[*\[18\]*](https://docs.convex.dev/database/schemas#:~:text=export%20default%20defineSchema%28,name%3A%20v.string%28%29%2C%20tokenIdentifier%3A%20v.string) [*\[21\]*](https://docs.convex.dev/database/schemas#:~:text=user%3A%20v.id%28,) [*\[64\]*](https://docs.convex.dev/database/schemas#:~:text=defineTable%28%7B%20oneTwoOrThree%3A%20v.union%28%20v.literal%28,%29%2C) [*\[65\]*](https://docs.convex.dev/database/schemas#:~:text=Generating%20a%20Schema) Schemas | Convex Developer Hub

[*https://docs.convex.dev/database/schemas*](https://docs.convex.dev/database/schemas)

[*\[19\]*](https://docs.convex.dev/database/document-ids#:~:text=In%20Convex%2C%20you%20can%20reference,in%20another%20document) [*\[20\]*](https://docs.convex.dev/database/document-ids#:~:text=const%20user%20%3D%20await%20ctx) [*\[22\]*](https://docs.convex.dev/database/document-ids#:~:text=Using%20,build%20a%20complex%20data%20model) [*\[23\]*](https://docs.convex.dev/database/document-ids#:~:text=Trading%20off%20deeply%20nested%20documents,relationships) [*\[24\]*](https://docs.convex.dev/database/document-ids#:~:text=function%20and%20get%20the%20corresponding,type) [*\[25\]*](https://docs.convex.dev/database/document-ids#:~:text=) Document IDs | Convex Developer Hub

[*https://docs.convex.dev/database/document-ids*](https://docs.convex.dev/database/document-ids)

[*\[26\]*](https://docs.convex.dev/file-storage/upload-files#:~:text=The%20custom%20upload%20HTTP%20action,is%20currently%20limited%20to%2020MB) [*\[28\]*](https://docs.convex.dev/file-storage/upload-files#:~:text=1,data%20model%20via%20another%20mutation) [*\[29\]*](https://docs.convex.dev/file-storage/upload-files#:~:text=%2F%2F%20Step%201%3A%20Get%20a,%3D%20await%20result.json) Uploading and Storing Files | Convex Developer Hub

[*https://docs.convex.dev/file-storage/upload-files*](https://docs.convex.dev/file-storage/upload-files)

[*\[27\]*](https://docs.convex.dev/file-storage/serve-files#:~:text=take%20some%20parameter,or%20a%20storage%20ID%20itself) [*\[30\]*](https://docs.convex.dev/file-storage/serve-files#:~:text=const%20messages%20%3D%20await%20ctx.db.query%28,) [*\[31\]*](https://docs.convex.dev/file-storage/serve-files#:~:text=You%20can%20serve%20files%20directly,or%20a%20storage%20ID%20itself) [*\[32\]*](https://docs.convex.dev/file-storage/serve-files#:~:text=const%20http%20%3D%20httpRouter) [*\[33\]*](https://docs.convex.dev/file-storage/serve-files#:~:text=In%20your%20query%20you%20can,file%20serving%20HTTP%20actions%20instead) Serving Files | Convex Developer Hub

[*https://docs.convex.dev/file-storage/serve-files*](https://docs.convex.dev/file-storage/serve-files)

[*\[34\]*](https://docs.convex.dev/file-storage#:~:text=,Access%20file%20metadata) [*\[35\]*](https://docs.convex.dev/file-storage#:~:text=,Access%20file%20%2018) File Storage | Convex Developer Hub

[*https://docs.convex.dev/file-storage*](https://docs.convex.dev/file-storage)

[*\[36\]*](https://docs.convex.dev/functions/mutation-functions#:~:text=Mutations%20,third%20party%20APIs%2C%20use%20actions) Mutations | Convex Developer Hub

[*https://docs.convex.dev/functions/mutation-functions*](https://docs.convex.dev/functions/mutation-functions)

[*\[37\]*](https://docs.convex.dev/functions/actions#:~:text=Unlike%20queries%20and%20mutations%2C%20actions,For%20example%2C%20say%20your) Actions | Convex Developer Hub

[*https://docs.convex.dev/functions/actions*](https://docs.convex.dev/functions/actions)

[*\[38\]*](https://docs.convex.dev/production/environment-variables#:~:text=Environment%20variables%20are%20key,process.env) [*\[39\]*](https://docs.convex.dev/production/environment-variables#:~:text=Accessing%20environment%20variables) [*\[85\]*](https://docs.convex.dev/production/environment-variables#:~:text=Setting%20environment%20variables) [*\[86\]*](https://docs.convex.dev/production/environment-variables#:~:text=Environment%20variables%20can%20also%20be,modified%20with%20the%20command%20line) Environment Variables | Convex Developer Hub

[*https://docs.convex.dev/production/environment-variables*](https://docs.convex.dev/production/environment-variables)

[*\[40\]*](https://docs.convex.dev/api/interfaces/server.Scheduler#:~:text=Interface%3A%20Scheduler%20,runAfter) Interface: Scheduler | Convex Developer Hub

[*https://docs.convex.dev/api/interfaces/server.Scheduler*](https://docs.convex.dev/api/interfaces/server.Scheduler)

[*\[41\]*](https://docs.convex.dev/scheduling/cron-jobs#:~:text=Convex%20allows%20you%20to%20schedule,schedule%20a%20backup%20every%20Saturday) [*\[42\]*](https://docs.convex.dev/scheduling/cron-jobs#:~:text=,creating%20schedules%20in%20this%20format) [*\[43\]*](https://docs.convex.dev/scheduling/cron-jobs#:~:text=Supported%20schedules%20below) [*\[44\]*](https://docs.convex.dev/scheduling/cron-jobs#:~:text=const%20crons%20%3D%20cronJobs) [*\[45\]*](https://docs.convex.dev/scheduling/cron-jobs#:~:text=crons.monthly%28%20,argument%20to%20sendPaymentEmail) [*\[46\]*](https://docs.convex.dev/scheduling/cron-jobs#:~:text=Error%20handling) [*\[47\]*](https://docs.convex.dev/scheduling/cron-jobs#:~:text=Viewing%20your%20cron%20jobs) Cron Jobs | Convex Developer Hub

[*https://docs.convex.dev/scheduling/cron-jobs*](https://docs.convex.dev/scheduling/cron-jobs)

[*\[48\]*](https://www.reddit.com/r/nextjs/comments/1juhpvg/yall_sleeping_on_convex/#:~:text=You%20use%20them%20directly%20in,hooks%20allow%20seamless%20interaction) Y'all sleeping on Convex : r/nextjs \- Reddit

[*https://www.reddit.com/r/nextjs/comments/1juhpvg/yall\_sleeping\_on\_convex/*](https://www.reddit.com/r/nextjs/comments/1juhpvg/yall_sleeping_on_convex/)

[*\[51\]*](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=Preloading%20data%20for%20Client%20Components) [*\[52\]*](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=import%20,Tasks) [*\[53\]*](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=In%20a%20Client%20Component%20call,usePreloadedQuery) [*\[54\]*](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=export%20function%20Tasks%28props%3A%20,div%3E%3B) [*\[55\]*](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=If%20you%20want%20to%20preload,preloadQuery%20%20from%20%2050) [*\[56\]*](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=import%20,convex%2F_generated%2Fapi) [*\[57\]*](https://docs.convex.dev/client/nextjs/app-router/server-rendering#:~:text=Using%20Convex%20to%20render%20Server,Components) Next.js Server Rendering | Convex Developer Hub

[*https://docs.convex.dev/client/nextjs/app-router/server-rendering*](https://docs.convex.dev/client/nextjs/app-router/server-rendering)

[*\[58\]*](https://docs.convex.dev/database/import-export/import#:~:text=Import%20a%20CSV%2C%20JSON%2C%20or,file%20into%20a%20Convex%20table) [*\[59\]*](https://docs.convex.dev/database/import-export/import#:~:text=Features) [*\[60\]*](https://docs.convex.dev/database/import-export/import#:~:text=Import%20from%20a%20Backup%20into,references%20between%20tables%20are%20maintained) [*\[61\]*](https://docs.convex.dev/database/import-export/import#:~:text=,data.jsonl) [*\[62\]*](https://docs.convex.dev/database/import-export/import#:~:text=Single%20table%20import) [*\[63\]*](https://docs.convex.dev/database/import-export/import#:~:text=Imports%20into%20a%20table%20with,the%20table%20with%20your%20import) [*\[77\]*](https://docs.convex.dev/database/import-export/import#:~:text=1,sample%20data) [*\[78\]*](https://docs.convex.dev/database/import-export/import#:~:text=3,the%20root%20of%20the%20repo) Data Import | Convex Developer Hub

[*https://docs.convex.dev/database/import-export/import*](https://docs.convex.dev/database/import-export/import)

[*\[66\]*](https://gist.github.com/srizvi/966e583693271d874bf65c2a95466339#:~:text=,) Opinionated guidelines and best practices for building Convex ...

[*https://gist.github.com/srizvi/966e583693271d874bf65c2a95466339*](https://gist.github.com/srizvi/966e583693271d874bf65c2a95466339)

[*\[69\]*](https://docs.convex.dev/testing#:~:text=%60convex) [*\[70\]*](https://docs.convex.dev/testing#:~:text=Testing%20against%20a%20real%20backend) [*\[79\]*](https://docs.convex.dev/testing#:~:text=Set%20up%20testing%20in%20CI) [*\[80\]*](https://docs.convex.dev/testing#:~:text=It%27s%20a%20good%20idea%20to,run%20them%20with%20GitHub%20Actions) Testing | Convex Developer Hub

[*https://docs.convex.dev/testing*](https://docs.convex.dev/testing)

[*\[71\]*](https://docs.convex.dev/functions/debugging#:~:text=The%20Convex%20backend%20also%20automatically,errors%20thrown%20by%20your%20functions) [*\[72\]*](https://docs.convex.dev/functions/debugging#:~:text=1,logs%2C%20which%20only%20prints%20logs) [*\[73\]*](https://docs.convex.dev/functions/debugging#:~:text=During%20development%20the%20built,going%20on%20inside%20your%20functions) [*\[74\]*](https://docs.convex.dev/functions/debugging#:~:text=,console.trace) [*\[75\]*](https://docs.convex.dev/functions/debugging#:~:text=To%20find%20the%20appropriate%20logs,request_id) [*\[76\]*](https://docs.convex.dev/functions/debugging#:~:text=1,of%20your%20backend%20to%20production) Debugging | Convex Developer Hub

[*https://docs.convex.dev/functions/debugging*](https://docs.convex.dev/functions/debugging)

[*\[81\]*](https://supabase.com/docs/guides/platform/backups#:~:text=Backup%20process%20) [*\[82\]*](https://supabase.com/docs/guides/platform/backups#:~:text=Database%20backups%20do%20not%20include,have%20been%20deleted%20since%20then) [*\[83\]*](https://supabase.com/docs/guides/platform/backups#:~:text=Once%20a%20project%20is%20deleted,be%20carefully%20considered%20before%20proceeding) Database Backups | Supabase Docs

[*https://supabase.com/docs/guides/platform/backups*](https://supabase.com/docs/guides/platform/backups)

[*\[84\]*](https://github.com/get-convex/convex-backend/issues/191#:~:text=Convex%20CLI%20always%20creates%20,the%20required%20environment%20variables) Convex CLI always creates .env.local even when environment ...

[*https://github.com/get-convex/convex-backend/issues/191*](https://github.com/get-convex/convex-backend/issues/191)

